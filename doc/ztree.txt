ztree(3)
========

NAME
----
ztree - generic type-free binary tree

SYNOPSIS
--------
----

//  Opaque class structure
typedef struct _ztree_t ztree_t;

//  @interface
//  Callback function for ztee_walk method
typedef int (ztree_walk_fn) (const char *key, void *value, void *argument);

//  Callback function for ztree_freefn method
typedef void (ztree_free_fn) (void *data);

//  Comparison function for ztree ordering
//  returns -1 for key1 < key2, 0 if key1 == key 2, 1 for key1 > key2
//  if key's are strings okay to use strcmp as function
typedef int (ztree_compare_fn) (const void *key1, const void *key2);

//  Create a new tree container
CZMQ_EXPORT ztree_t *
    ztree_new (ztree_compare_fn *compare_func);

//  Destroy a tree container
CZMQ_EXPORT void
    ztree_destroy (ztree_t **self_p);

//  Insert node into tree with specified key and item
//  If key is already present returns -1 and leaves existing item unchanged
//  Returns 0 on success.
CZMQ_EXPORT int
    ztree_insert (ztree_t *self, const char *key, void *item);

//  Update node in tree with specified key and item.
//  If key is already present, destroys old item and inserts new one.
//  Use free_fn method to ensure deallocator is properly called on item.
CZMQ_EXPORT void
    ztree_update (ztree_t *self, const char *key, void *item);

//  Remove an item specified by key from the tree. If there was no such
//  item, this function does nothing.
CZMQ_EXPORT void
    ztree_delete (ztree_t *self, const char *key);

//  Return the item at the specified key, or null
CZMQ_EXPORT void *
    ztree_lookup (ztree_t *self, const char *key);

//  Remove the specified item from the tree if present
CZMQ_EXPORT void
    ztree_remove (ztree_t *self, void *item);

//  Set a free function for the specified tree item. When the item is
//  destroyed, the free function, if any, is called on that item.
//  Use this when tree items are dynamically allocated, to ensure that
//  you don't have memory leaks. You can pass 'free' or NULL as a free_fn.
//  Returns the item, or NULL if there is no such item.
CZMQ_EXPORT void *
    ztree_freefn (ztree_t *self, const char *key, ztree_free_fn *free_fn);

//  Return the number of keys/items in the tree
CZMQ_EXPORT size_t
    ztree_size (ztree_t *self);

//  Return keys for items in tree
CZMQ_EXPORT zlist_t *
    ztree_keys (ztree_t *self);

//  Copy the entire tree, return the copy
CZMQ_EXPORT ztree_t *
    ztree_dup (ztree_t *self);

// Walk the tree depth-first, left-to-right order.
// Stops if callback function returns non-zero and returns
// final return code from callback function (zero = success).
CZMQ_EXPORT int
    ztree_walk (ztree_t *self, ztree_walk_fn *callback, void *argument);

//  Set tree for automatic item destruction
CZMQ_EXPORT void
    ztree_autofree (ztree_t *self);

//  Self test of this class
CZMQ_EXPORT void
    ztree_test (int verbose);
----

DESCRIPTION
-----------

Autoleveling tree container

Implemented internally as a red-black tree.

EXAMPLE
-------
.From ztree_test method
----
----
    ztree_t *tree = ztree_new (test_cmp);
    assert (tree);
    assert (ztree_size (tree) == 0);

    assert (ztree_lookup (tree, "NOTHING") == NULL);

    //  Insert some items
    int rc;
    rc = ztree_insert (tree, "DEADBEEF", "dead beef");
    assert (rc == 0);
    rc = ztree_insert (tree, "ABADCAFE", "a bad cafe");
    assert (rc == 0);
    rc = ztree_insert (tree, "C0DEDBAD", "coded bad");
    assert (rc == 0);
    rc = ztree_insert (tree, "DEADF00D", "dead food");
    assert (rc == 0);
    assert (ztree_size (tree) == 4);

    //  Look for existing items
    char *item;
    item = (char *) ztree_lookup (tree, "DEADBEEF");
    assert (streq (item, "dead beef"));
    item = (char *) ztree_lookup (tree, "ABADCAFE");
    assert (streq (item, "a bad cafe"));
    item = (char *) ztree_lookup (tree, "C0DEDBAD");
    assert (streq (item, "coded bad"));
    item = (char *) ztree_lookup (tree, "DEADF00D");
    assert (streq (item, "dead food"));

    //  Look for non-existent items
    item = (char *) ztree_lookup (tree, "foo");
    assert (item == NULL);

    //  Try to insert duplicate items
    rc = ztree_insert (tree, "DEADBEEF", "foo");
    assert (rc == -1);
    item = (char *) ztree_lookup (tree, "DEADBEEF");
    assert (streq (item, "dead beef"));

    //  Test keys method
    zlist_t *keys = ztree_keys (tree);
    assert (zlist_size (keys) == 4);

    // Test that keys are in order
    void *key, *pred;
    pred = zlist_first (keys);
    assert(pred);
    while ((key = zlist_next (keys))) {
	assert(strcmp(key, pred) > 0);
	pred = key;
    }
    zlist_destroy (&keys);

    //  Test dup method
    ztree_t *copy = ztree_dup (tree);
    assert (ztree_size (copy) == 4);
    item = (char *) ztree_lookup (copy, "DEADF00D");
    assert (item);
    assert (streq (item, "dead food"));
    ztree_destroy (&copy);

    // Test walk
    assert (0 == ztree_walk(tree, test_walk, tree));
    assert (-1 == ztree_walk(tree, test_walk_error, tree));

    //  Delete a item
    assert (ztree_size (tree) == 4);
    ztree_delete (tree, "DEADF00D");
    item = (char *) ztree_lookup (tree, "DEADF00D");
    assert (item == NULL);
    assert (ztree_size (tree) == 3);

    // Delete all items
    keys = ztree_keys (tree);
    assert (zlist_size (keys) == 3);
    while ((key = zlist_next (keys))) {
	    printf("delete '%s'\n", (char *) key);
	ztree_delete (tree, key);
    }
    zlist_destroy (&keys);
    assert (ztree_size (tree) == 0);

    //  Check that the queue is robust against random usage
    struct {
        char name [100];
        bool exists;
    } testset [200];
    memset (testset, 0, sizeof (testset));
    int testmax = 200, testnbr, iteration;

    srandom ((unsigned) time (NULL));
    for (iteration = 0; iteration < 25000; iteration++) {
        testnbr = randof (testmax);
        if (testset [testnbr].exists) {
            item = (char *) ztree_lookup (tree, testset [testnbr].name);
            assert (item);
            ztree_delete (tree, testset [testnbr].name);
            testset [testnbr].exists = false;
        }
        else {
            sprintf (testset [testnbr].name, "%x-%x", rand (), rand ());
            if (ztree_insert (tree, testset [testnbr].name, "") == 0)
                testset [testnbr].exists = true;
        }
    }
    //  Test 10K lookups
    for (iteration = 0; iteration < 10000; iteration++)
        item = (char *) ztree_lookup (tree, "DEADBEEFABADCAFE");

    //  Destructor should be safe to call twice
    ztree_destroy (&tree);
    ztree_destroy (&tree);
    assert (tree == NULL);

SEE ALSO
--------
linkczmq:czmq[7]
