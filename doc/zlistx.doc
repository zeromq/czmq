#### zlistx - extended generic list container

Provides a generic doubly-linked list container. This container provides
hooks for duplicator, comparator, and destructor functions. These tie
into CZMQ and standard C semantics, so e.g. for string items you can
use strdup, strcmp, and zstr_free. To store custom objects, define your
own duplicator and comparator, and use the standard object destructor.

This is a reworking of the old V2 list container. It is faster to insert
and delete items anywhere in the list, and to keep ordered lists.

This is the class interface:

    
    CZMQ_EXPORT
    
    //  Create a new, empty list.
    CZMQ_EXPORT zlistx_t *
        zlistx_new (void);
        
    //  Destroy a list. If an item destructor was specified, all items in the
    //  list are automatically destroyed as well.
    CZMQ_EXPORT void
        zlistx_destroy (zlistx_t **self_p);
        
    //  Add an item to the head of the list. Calls the item duplicator, if any,
    //  on the item. Resets cursor to list head. Returns an item handle on
    //  success, NULL if memory was exhausted.
    CZMQ_EXPORT void *
        zlistx_add_start (zlistx_t *self, void *item);
        
    //  Add an item to the tail of the list. Calls the item duplicator, if any,
    //  on the item. Resets cursor to list head. Returns an item handle on
    //  success, NULL if memory was exhausted.
    CZMQ_EXPORT void *
        zlistx_add_end (zlistx_t *self, void *item);
        
    //  Return the number of items in the list
    CZMQ_EXPORT size_t
        zlistx_size (zlistx_t *self);
        
    //  Return the item at the head of list. If the list is empty, returns NULL.
    //  Leaves cursor pointing at the head item, or NULL if the list is empty.
    CZMQ_EXPORT void *
        zlistx_first (zlistx_t *self);
        
    //  Return the next item. At the end of the list (or in an empty list),
    //  returns NULL. Use repeated zlistx_next () calls to work through the list
    //  from zlistx_first (). First time, acts as zlistx_first().
    CZMQ_EXPORT void *
        zlistx_next (zlistx_t *self);
    
    //  Return the previous item. At the start of the list (or in an empty list),
    //  returns NULL. Use repeated zlistx_prev () calls to work through the list
    //  backwards from zlistx_last (). First time, acts as zlistx_last().
    CZMQ_EXPORT void *
        zlistx_prev (zlistx_t *self);
        
    //  Return the item at the tail of list. If the list is empty, returns NULL.
    //  Leaves cursor pointing at the tail item, or NULL if the list is empty.
    CZMQ_EXPORT void *
        zlistx_last (zlistx_t *self);
    
    //  Returns the value of the item at the cursor, or NULL if the cursor is
    //  not pointing to an item.
    CZMQ_EXPORT void *
        zlistx_item (zlistx_t *self);
    
    //  Returns the handle of the item at the cursor, or NULL if the cursor is
    //  not pointing to an item.
    CZMQ_EXPORT void *
        zlistx_handle (zlistx_t *self);
    
    //  Find an item in the list, searching from the start. Uses the item
    //  comparator, if any, else compares item values directly. Returns the
    //  item handle found, or NULL. Sets the cursor to the found item, if any.
    CZMQ_EXPORT void *
        zlistx_find (zlistx_t *self, void *item);
    
    //  Detach an item from the list, using its handle. The item is not modified,
    //  and the caller is responsible for destroying it if necessary. If handle is
    //  null, detaches the first item on the list. Returns item that was detached,
    //  or null if none was.
    CZMQ_EXPORT void *
        zlistx_detach (zlistx_t *self, void *handle);
    
    //  Delete an item, using its handle. Calls the item destructor is any is
    //  set. If handle is null, deletes the first item on the list.
    CZMQ_EXPORT int
        zlistx_delete (zlistx_t *self, void *handle);
        
    //  Move an item to the start of the list, via its handle. If sorted is true,
    //  the item is inserted before the first item with a higher value, determined
    //  by the item comparator (or item value if no comparator is set).
    CZMQ_EXPORT void
        zlistx_move_start (zlistx_t *self, void *handle, bool sorted);
    
    //  Move an item to the end of the list, via its handle. If sorted is true,
    //  the item is inserted after the last item with a lower value, determined
    //  by the item comparator (or item value if no comparator is set).
    CZMQ_EXPORT void
        zlistx_move_end (zlistx_t *self, void *handle, bool sorted);
    
    //  Remove all items from the list, and destroy them if the item destructor
    //  is set.
    CZMQ_EXPORT void
        zlistx_purge (zlistx_t *self);
        
    //  Sort the list. If an item comparator was set, calls that to compare
    //  items, otherwise compares on item value. The sort is not stable, so may
    //  reorder equal items.
    CZMQ_EXPORT void
        zlistx_sort (zlistx_t *self);
        
    //  Make a copy of the list; items are duplicated if you set a duplicator
    //  for the list, otherwise not. Copying a null reference returns a null
    //  reference.
    CZMQ_EXPORT zlistx_t *
        zlistx_dup (zlistx_t *self);
    
    //  Set a user-defined deallocator for list items; by default items are not
    //  freed when the list is destroyed.
    CZMQ_EXPORT void
        zlistx_set_destructor (zlistx_t *self, czmq_destructor destructor);
        
    //  Set a user-defined duplicator for list items; by default items are not
    //  copied when the list is duplicated.
    CZMQ_EXPORT void
        zlistx_set_duplicator (zlistx_t *self, czmq_duplicator duplicator);
    
    //  Set a user-defined comparator for zlistx_find and zlistx_sort; the method
    //  must return -1, 0, or 1 depending on whether item1 is less than, equal to,
    //  or greater than, item2.
    CZMQ_EXPORT void
        zlistx_set_comparator (zlistx_t *self, czmq_comparator comparator);
    
    //  Runs selftest of class
    CZMQ_EXPORT void
        zlistx_test (int verbose);
    

This is the class self test code:

    zlistx_t *list = zlistx_new ();
    assert (list);
    assert (zlistx_size (list) == 0);
    
    //  Test operations on an empty list
    assert (zlistx_first (list) == NULL);
    assert (zlistx_last (list) == NULL);
    assert (zlistx_next (list) == NULL);
    assert (zlistx_prev (list) == NULL);
    assert (zlistx_find (list, "hello") == NULL);
    assert (zlistx_delete (list, NULL) == -1);
    assert (zlistx_detach (list, NULL) == NULL);
    assert (zlistx_delete (list, NULL) == -1);
    assert (zlistx_detach (list, NULL) == NULL);
    zlistx_purge (list);
    zlistx_sort (list);
    
    //  Use item handlers
    zlistx_set_destructor (list, (czmq_destructor *) zstr_free);
    zlistx_set_duplicator (list, (czmq_duplicator *) strdup);
    zlistx_set_comparator (list, (czmq_comparator *) strcmp);
    
    //  Try simple insert/sort/delete/next
    assert (zlistx_next (list) == NULL);
    zlistx_add_end (list, "world");
    assert (streq ((char *) zlistx_next (list), "world"));
    zlistx_add_end (list, "hello");
    assert (streq ((char *) zlistx_prev (list), "hello"));
    zlistx_sort (list);
    assert (zlistx_size (list) == 2);
    void *handle = zlistx_find (list, "hello");
    zlistx_delete (list, handle);
    assert (zlistx_size (list) == 1);
    char *string = (char *) zlistx_detach (list, NULL);
    assert (streq (string, "world"));
    free (string);
    assert (zlistx_size (list) == 0);
    
    //  Check next/back work
    //  Now populate the list with items
    zlistx_add_start (list, "five");
    zlistx_add_end   (list, "six");
    zlistx_add_start (list, "four");
    zlistx_add_end   (list, "seven");
    zlistx_add_start (list, "three");
    zlistx_add_end   (list, "eight");
    zlistx_add_start (list, "two");
    zlistx_add_end   (list, "nine");
    zlistx_add_start (list, "one");
    zlistx_add_end   (list, "ten");
    
    //  Test our navigation skills
    assert (zlistx_size (list) == 10);
    assert (streq ((char *) zlistx_last (list), "ten"));
    assert (streq ((char *) zlistx_prev (list), "nine"));
    assert (streq ((char *) zlistx_prev (list), "eight"));
    assert (streq ((char *) zlistx_prev (list), "seven"));
    assert (streq ((char *) zlistx_prev (list), "six"));
    assert (streq ((char *) zlistx_prev (list), "five"));
    assert (streq ((char *) zlistx_first (list), "one"));
    assert (streq ((char *) zlistx_next (list), "two"));
    assert (streq ((char *) zlistx_next (list), "three"));
    assert (streq ((char *) zlistx_next (list), "four"));
    
    //  Sort by alphabetical order
    zlistx_sort (list);
    assert (streq ((char *) zlistx_first (list), "eight"));
    assert (streq ((char *) zlistx_last (list), "two"));
    
    //  Try moving items around
    handle = zlistx_find (list, "six");
    zlistx_move_start (list, handle, false);
    assert (streq ((char *) zlistx_first (list), "six"));
    zlistx_move_end (list, handle, false);
    assert (streq ((char *) zlistx_last (list), "six"));
    zlistx_sort (list);
    assert (streq ((char *) zlistx_last (list), "two"));
        
    zlistx_t *copy = zlistx_dup (list);
    assert (copy);
    assert (zlistx_size (copy) == 10);
    assert (streq ((char *) zlistx_first (copy), "eight"));
    assert (streq ((char *) zlistx_last (copy), "two"));
    zlistx_destroy (&copy);
    
    zlistx_purge (list);
    zlistx_destroy (&list);

