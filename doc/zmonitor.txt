zmonitor(3)
===========

NAME
----
zmonitor - socket event monitor

SYNOPSIS
--------
----
//  Create new zmonitor actor instance.
//
//      zactor_t *monitor = zactor_new (zmonitor, NULL);
//
//  Destroy zmonitor instance.
//
//      zactor_destroy (&monitor);
//
//  Enable verbose logging of commands and activity.
//
//      zstr_sendx (monitor, "VERBOSE", NULL);
//
//  Listen to monitor event type:
//      zstr_sendx (monitor, "LISTEN", type, type, type, NULL);
//  
//      Events:
//      CONNECTED
//      CONNECT_DELAYED
//      CONNECT_RETRIED
//      LISTENING
//      BIND_FAILED
//      ACCEPTED
//      ACCEPT_FAILED
//      CLOSED
//      CLOSE_FAILED
//      DISCONNECTED
//      MONITOR_STOPPED
//      ALL
//
//  Start monitor; after this, any further LISTEN commands are ignored.
//
//      zstr_sendx (monitor, "START", NULL);
//      zsock_wait (monitor);
//
//  Receive next monitor event:
//
//      zmsg_t *msg = zmsg_recv (monitor);
//
//  This is the zmonitor constructor as a zactor_fn:
CZMQ_EXPORT void
    zmonitor (zsock_t *pipe, void *args);

//  Selftest
CZMQ_EXPORT void
    zmonitor_test (bool verbose);
----

DESCRIPTION
-----------

The zmonitor actor provides an API for obtaining socket events such as
connected, listen, disconnected, etc. Socket events are only available
for sockets connecting or bound to ipc:// and tcp:// endpoints.

This class wraps the ZMQ socket monitor API, see zmq_socket_monitor for
details. Currently this class requires libzmq v4.0 or later and is empty
on older versions of libzmq.

EXAMPLE
-------
.From zmonitor_test method
----
    zsock_t *client = zsock_new (ZMQ_DEALER);
    zactor_t *clientmon = zactor_new (zmonitor, client);
    assert (clientmon);
    if (verbose)
        zstr_sendx (clientmon, "VERBOSE", NULL);
    zstr_sendx (clientmon, "LISTEN", "LISTENING", "ACCEPTED", NULL);
    zstr_sendx (clientmon, "START", NULL);
    zsock_wait (clientmon);

    zsock_t *server = zsock_new (ZMQ_DEALER);
    zactor_t *servermon = zactor_new (zmonitor, server);
    assert (servermon);
    if (verbose)
        zstr_sendx (servermon, "VERBOSE", NULL);
    zstr_sendx (servermon, "LISTEN", "CONNECTED", "DISCONNECTED", NULL);
    zstr_sendx (servermon, "START", NULL);
    zsock_wait (servermon);
    
    //  Allow a brief time for the message to get there...
    zmq_poll (NULL, 0, 200);

    //  Check client is now listening
    int port_nbr = zsock_bind (client, "tcp://127.0.0.1:*");
    assert (port_nbr != -1);
    s_assert_event (clientmon, "LISTENING");

    //  Check server connected to client
    zsock_connect (server, "tcp://127.0.0.1:%d", port_nbr);
    s_assert_event (servermon, "CONNECTED");

    //  Check client accepted connection
    s_assert_event (clientmon, "ACCEPTED");

    zactor_destroy (&clientmon);
    zactor_destroy (&servermon);
    zsock_destroy (&client);
    zsock_destroy (&server);
#endif
----

SEE ALSO
--------
linkczmq:czmq[7]
